<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raylib, C, Physics and WebAssembly</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <header>
  <nav>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="https://github.com/nailuj05">Github</a></li>
      <li><a href="contact.html">Contact</a></li>
    </ul>
  </nav>
</header>


  <div class="content-wrapper">
    <details open class="recent-entries">
      <summary>Recent Blog Entries</summary>
      <ul>
        
<li><a href="Building this blog.html">Building this blog</a></li>
<li><a href="Raylib, C, Physics and WebAssembly.html">Raylib, C, Physics and WebAssembly</a></li>
      </ul>
    </details>

    <section class="main-text">
      <!-- <h1>Blog Post Title 1</h1> -->
      <!-- <p>Posted on [Date]</p> -->
      <!-- <article> -->
      <!--   <p>This is the content of your blog post. You can write as much as you want here.</p> -->
      <!-- </article> -->
      <h1>Raylib, C, Physics and WebAssembly</h1><br>After seeing <a href="https://store.steampowered.com/app/3117780/YinYang_PingPong/">this</a> Yin-Yang Ping-Pong somewhere online, I was inspired to build a similar application myself as a nice exercise. And during my last longer train ride I had the time to do just so! (I have later found out that it is in fact yin yang and not ying yang .-.)<br><br><img src="_images/output.gif"><br><br>I really enjoyed working in C and Raylib recently (Raylib really deserves its own blog post in the future) so that is what I chose. For the uninitiated, Raylib is a "simple and easy-to-use library to enjoy video games programming". It provides a framework to build graphical applications, without the hassle of using platform specific APIs or setting up a OpenGL/Vulcan Pipeline yourself. In my opinion it is somewhat comparable to SDL, but simpler and more hackable. With raylib being simple I mean it is easy to use, its feature set is still really powerful.<br><br>The main application turned out to be simpler than expected, the yin-yang grid is represented as an array of booleans. The balls are structs comprised of their position, velocity and color, which is enough to handle the physics. For the physics I started with a basic gravity acceleration, as just a continuous integration of the velocity (on the y-axis). Done, next up: Collisions. At first, I implemented the border collisions, they are rather easy, you just need to check whether a ball has left the range of your window on either axis and, if so, reflect its velocity along the normal of the border it exited. For the actual collision checks I always treat the ball as if it was a point, which simplifies the math and is barely noticeable.<br><br><img src="_images/Reflection-sketch.png"><br><i>A sketch showing the reflection of the balls velocity along a border</i><br><br>When thinking about implementing this I tried to work out a way to calculate the balls collision with the edge line between the grid cells of different colors. This approach has a few big drawbacks though, firstly getting/keeping track of the edges between the opposing cells would be a big task. This would also include handling edge cases such as isolated islands of grid cells and the ball hitting the exact corner of two edges.<br><br>So why not simplify it, I thought, I could always go back to the more complicated result if I wasn't happy with the simpler version.<br><br>My second approach was stupidly simple, just iterate over all cells and check whether they overlap with a ball of the opposing color, if so, remove the cell and reflect the ball along the axis of higher velocity. This means if the ball is going fast on its x-axis, it would be reflected along the x as the normal. While this solution isn't really an accurate simulation, it does the trick, along with being easy to implement and calculate.<br><br>So with this cool simulation being done I want to share it with people, but I don't want to force people to download, build and run a project, just for a few seconds of watching a ball bounce around. This is where the idea of WebAssembly comes into play. WASM is a way to compile programs to run in a browser, similar to JavaScript, but usually more performant.<br><br>Raylib also offers WebAssembly as a compilation backend, it is pretty straight forward and the process is well explained <a href="https://github.com/raysan5/raylib/wiki/Working-for-Web-(HTML5">here</a>). In the end your application will compile to HTML file which contains a canvas onto which a JavaScript loader will draw the output of your WASM Application.<br><br><img src="_images/Pasted image 20240927174236.png"><br><br>The application itself only needed minor changes, due to the way browsers work you cannot simply put your games main loop into the standard <code>while(!WindowShouldClose())</code> as you would usually do using Raylib. Instead, you'll refactor your main loop into a separate function which can then be called by the emscripten loop handler.<br><br>For compiling it all I added a <code>web</code>-flag to my noob build system.<br><br>With that done all that was left to do was deployin to GitHub Pages and writing this post. You can check it all out here:<br><br><a href="https://github.com/nailuj05/ying-yang-ping-pong">GitHub</a><br><a href="https://nailuj05.github.io/ying-yang-ping-pong/">Web Version</a> (Set the page to desktop-mode on mobile)<br><br>
    </section>
  </div>

  <footer>
  <p>&copy; 2024 Julian Limburg</p>
</footer>

</body>

</html>
